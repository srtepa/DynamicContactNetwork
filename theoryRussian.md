---
title: Структура данных DSU (Union-Find)
weight: 2
authors:
    - Сергей Слотин
created: 2019
---

У алгоритмов на графах часто возникает подзадача отслеживания связности. Если мы решаем задачу в статике, достаточно обхода в ширину или глубину. Но если ребра добавляются динамически, пересчитывать компоненты каждый раз за $O(V+E)$ — слишком медленно. Нам нужна структура, которая умеет делать это почти мгновенно.

Такая структура называется **Система непересекающихся множеств** (DSU — Disjoint Set Union). Формально, у нас есть $n$ элементов, каждый изначально в своем множестве. Мы хотим быстро делать две вещи:

1.  **Union**: Объединить два множества, в которых лежат элементы $a$ и $b$.
2.  **Find**: Узнать, в каком множестве лежит элемент (вернуть его представителя).

Обе операции мы хотим выполнять за (почти) $O(1)$. СНМ — это стандарт де-факто для алгоритма Краскала (поиск минимального остовного дерева) и поиска компонент связности.

## Внутреннее устройство

Мы будем хранить множества в виде **деревьев**. Одно дерево = одно множество.
Корень дерева — это **лидер** (представитель) всего множества.
Главное правило: *для корня дерева предком является он сам*.

Хранить это будем в массиве `p`, где `p[i]` — предок элемента `i`.

```
int p[maxn];

// Изначально каждый сам себе лидер
for (int i = 0; i < n; i++)
    p[i] = i;
```

Чтобы найти лидера элемента $v$, мы просто поднимаемся по ссылкам вверх, пока не найдем вершину, где `p[root] == root`.

Чтобы объединить два множества (`unite(a, b)`), мы находим лидеров обоих элементов и подвешиваем один корень к другому: `p[leader_a] = leader_b`.

**Проблема наивной реализации:**
В худшем случае такая структура вырождается в «бамбук» (длинную цепочку). Представьте, что мы всегда подвешиваем более глубокое дерево к листу. Тогда операция поиска лидера будет работать за $O(n)$. Если у нас $M$ запросов, мы получим $O(M \cdot n)$ и TL (Time Limit Exceeded).

Нам нужно гарантировать, что деревья останутся низкими.

## Оптимизации

Чтобы DSU работал быстро, применяются две эвристики.

**1. Сжатие путей (Path Compression)**
Идея проста: пока мы ищем корня для вершины $v$, мы проходим по цепочке предков. Почему бы сразу не переподвесить их всех напрямую к корню? В следующий раз искать лидера для них будет моментально.

```
int leader(int v) {
    // Если v - корень, возвращаем его.
    // Иначе ищем лидера для предка и сразу запоминаем результат в p[v].
    return (p[v] == v) ? v : p[v] = leader(p[v]);
}
```

**2. Эвристика объединения (Union by Rank / Size)**
Эта эвристика контролирует высоту дерева при объединении. Мы всегда хотим подвешивать **меньшее** дерево к **большему**.

*   *Ранговая эвристика:* храним приблизительную высоту дерева ($rank$). Подвешиваем дерево с меньшим рангом к дереву с большим. Если ранги равны, новый корень увеличивает ранг на 1.
*   *Весовая эвристика:* храним размер поддерева ($size$). Подвешиваем то, где меньше вершин, к тому, где больше.

Пример объединения по размеру (наиболее часто используется, так как размеры множеств часто нужны в самой задаче):

```
int s[maxn]; // s[i] = 1 изначально

void unite(int a, int b) {
    a = leader(a);
    b = leader(b);
    if (a == b) return; // Уже в одном множестве

    // Хотим, чтобы 'a' было меньше, чтобы подвесить его к 'b'
    if (s[a] > s[b]) swap(a, b);
    
    s[b] += s[a]; // Обновляем размер большего
    p[a] = b;     // Подвешиваем меньшее
}
```

Использовать нужно **обе** оптимизации сразу. Сжатие путей ускоряет поиск, а правильное объединение не дает дереву расти в высоту.

## Асимптотика

> При использовании обеих эвристик (сжатие путей + ранговая/весовая) среднее время работы одной операции составляет $O(\alpha(n))$.

Здесь $\alpha(n)$ — обратная функция Аккермана.

**Что нужно знать про $\alpha(n)$:**
Функция Аккермана растет невообразимо быстро. Соответственно, обратная функция растет невообразимо медленно.
Для любых чисел, которые вы можете встретить во Вселенной (скажем, $n \le 10^{600}$), справедливо:
$$
\alpha(n) \le 4
$$

Поэтому на практике можно смело считать, что DSU работает за **константное время** $O(1)$.

**Доказательство** (для любителей теории):
В общем случае без сжатия путей, но с ранговой эвристикой, высота дерева логарифмическая $O(\log n)$. Сжатие путей делает структуру еще более плоской. Строгое доказательство оценки через функцию Аккермана занимает несколько страниц и требует сложных амортизационных анализов.
